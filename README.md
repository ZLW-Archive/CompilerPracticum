# 编译实习 课程项目

王子龙、费天一

 ***miniJava ->  sPiglet -> kanga -> mips***  

## 一、miniJava 类型检查

1. 定义符号表：
    - `MType`：记录当前对象的类型；
    - `MClassList (extends MType)`：记录从`Class`名称到`MClass`的映射
    - `MIdentifier (extends MType)`：记录当前对象的名称、行、列
    - `MClass (extends MIdentifier)`：记录当前类中从名称到变量`MVar`或方法`MMethod`的映射
    - `MMethod (extends MIdentifier)`：记录所属类、返回类型、参数变量列表、内部变量列表
    - `MVar (extends MIdentifier)`：记录当前变量所属对象（`MMethod` 或 `MClass`）

2. 构造符号表 (`BuildSymbolTableVisitor extends GJDepthFirst<MType, MType>`)：
    - 通过深度优先搜索将对应的类与对象保存在`MClassList`类型中
    - 在构造`MClassList`时只检查是否存在重复定义的类、方法、变量
    - 由于类与类之间的继承关系不一定遵循时序，可能继承时，父类尚未声明，于是在先不生成继承关系

3. 类型检查 (`TypeCheckVisitor extends GJDepthFirst <MType, MType>`)：
    - 完成类之间继承关系；检查循环继承；检查方法重载
    - 检查方法的返回值和声明的返回值是否匹配（在检查类之间匹配时，考虑继承关系，见`MClass::checkExtendAssign(String left, String right)`）
    - 在各个算数运算和分支、循环、打印等结构处检查变量的类型
    - 在遇到`<IDENTIFIER>`时，检查是否是未声明的变量，通过参数`argu`的类型分类讨论
    - 检查函数调用时，通过全局变量`curFormalParaCheckMethod`传递当前需要检查的方法，通过`MClass::startCheckFormalPara(), checkingFormalPara(String curParaType, MClassList allClassList), endCheckFormalPara()`，以及构造符号表时记录的参数顺序，完成检查实际参数和声明参数是否匹配

## 二、minijava -> spiglet

1. 这一步需要将minijava翻译为spiglet中间代码。这一步首先需要通过符号表实现实例表的构造。
   - 实例表的第一项是一个指向方法表的指针，实例表的第二项开始则是实例的各个属性。在我们的实现中，一个类的所有实例共用一个全局的方法表，但是每一个实例的属性表是私有的。
   - 为了实现方法表中的覆盖，方法表中的每一项可以表示为`{Methodname}:bias`。在构造每一个类的方法表，我们需要通过符号表首先构建子类的方发表再依次加入父类的方法。加入父类方法时需要首先查找子类的方法表中是否存在：如果存在，直接使用父类的方法覆盖子类的方法。如果不存在，则为方法表新加一项该方法。
   - 而构造属性表时，则需要考虑父类与子类的隐藏特性。属性表中的每一项可以表示为`{Classname_Methodname}:bias`。在构建出子类的属性表之后直接在表后添加父类的所有属性。
2. 第二步要实现的是函数名以及参数的设计。
   - 这里我们将所有的方法名设计为`{Classname}_{Methodname}`。我们在实现spiglet时为所有的程序构造相同的main函数：该函数首先调用一个构造全局的方法表的函数，然后跳转到真正的主函数开始运行。
   - 函数的参数列表设计为：
     - 0：`this`指针，指向实例表的指针
     - 1：`GLOBAL_CLASS_LIST`，指向全局方法表
     - 2~16：15个普通的参数
     - 17：`EXTENDED_PARAM_POINTER`，用于存放多于15个参数的扩展参数列表
     - 18~19：保留，没有使用
3. 从minijava到spiglet (`ToSPigletVisitor extends GJDepthFirst<PigletRet,PigletLabels>`)
   - 首先，每一个函数的输入参数是一个类`PigletLabels`，包含字段：
     - `varList`：记录当前函数的临时符号表
     - `paramlength`：当前处理的参数是第几个
     - `paramextend`：扩展参数列表指针
     - `mc`：函数所属的类的符号表项
     - `mm`：函数本身的符号表项
     - `intend`：记录当前位置的代码缩进长度
   - 其次，每一个函数的返回值是一个类`PigletRet`，包含字段：
     - `result`：表达式，标识符所对应的变量号
     - `type`：表达式，标识符所对应的类别
   - `ToSpigletVisitor`类的构造函数需要将生成的符号表作为参数，并初始化两个参数`temp`，用于生成一个新的变量，以及`label`，用于生成一个新的标签。
4. 实现要点介绍
   - 变量的选取：为了符合java中的隐藏特性，实现过程中对变量的选取是有严格的顺序的。首先从传入参数的临时变量列表中搜索是否有符合的变量，如有则直接使用。之后从当前类的属性中搜索，如果有，则从`this`指针所指向的实例表中选取特定的位置使用。否则就递归地寻找子类的属性列表中的变量使用。
   - 逻辑运算：这里我们实现了短路与，即`A && B`如果`A`是`false`，则不会计算`B`而直接将结果记录为`false`。`if`以及`while`语句的翻译都是按照书本上介绍的方法，通过插入`Noop`和标签实现逻辑。
   - 表达式计算：在计算过程中会对每一个中间结果申请一个新的变量保存。用过返回值将结果的类型以及所存的变脸号传回。之后的翻译过程中会通过变量的类型以及变量号选取相应的函数进行调用。
   - 参数表的构建：每当需要调用函数时，需要首先准备好对应的参数。这需要依次计算参数列表中的表达式并存放于一个变量中。最后call指定函数即可。在准备参数的过程中需要注意参数的数目，如果参数的数目多于15，则需要存放于扩展参数列表中。
   - 实例的创建：实例的创建主要是为其创建实例表。实例表的第一个是其方法表。这需要在全局方法表中进行查找，找到对应的方法表并填入。之后就是根据其属性表的大小申请对应大小的空间，并初始化为0。以上就完成了实例表的创建。
   - 数组的初始化：首先申请需要的空间+4字节的大小，在前4字节存放数组的大小，之后将数组之后的空间初始化为0。

## 三、sPiglet -> kanga

1. 定义符号表：
    - `FlowNode`：流图中的基本块（由于大作业时编译正课还没学相关知识，于是这里的基本块由单条语句组成），包含`in`、`out`、`def`、`use`等临时变量信息和`pre`、`next`流图结构信息
    - `FlowGraph`：流图，由若干`FlowNode`组成，每个过程生成一个流图
    - `IntervalAnalysis`：通过线性分析，分配寄存器，在`FlowGraph`中生成
    - `RegSelect`：当前寄存器分配的对应关系（临时变量映射到寄存器），记录在每个`FlowNode`中

2. 构造基本块和流图 (`BuildGraphVisitor extends GJNoArguDepthFirst<Object>`)：
    - 对每行语句生成基本块，同时记录当前块的`def`、`use`信息，并记录每个块之间的时序关系，注意`CJump`、`Jump`等语句的影响，由于跳转的label可能尚未生成，于是将跳转关系记录在`FlowGraph::pendingEdges`中
    - 在一个流图的若干基本块头和尾添加两个独立的基本块`Entry`、`Exit`
    - 在`FlowGraph::finishGraph()`中完成生成流图在最后工作：
      - 根据`FlowGraph::pendingEdges`回填跳转语句的前驱、后继信息
      - 分析活跃变量，生成每个基本块的`in`、`out`
      - 通过`IntervalAnalysis()`分配寄存器，在我们的实现中`s0-s7`、`t3-t9`都是被调用者保存寄存器，只有`t0-t2`用于临时变量寄存器，因为一条语句最多用到三个不同的临时变量：
        - 通过每个基本块的`in`、`out`信息，计算每个临时变量在当前流图中的开始活跃时间和停止活跃时间，即对应基本块的标号
        - 遍历每个基本块，为每个临时变量分配寄存器，当寄存器不够时，将当前活跃的最晚结束的寄存器入栈，在栈中的位置记为`Xi`，与寄存器命名一致，当有弹栈导致栈中间有空位，将这些空位记录在`stackMiddleAvailable`中，在下次入栈时优先考虑中间的空缺，否则扩大所需栈空间的容量
        - 在完成当前基本块的寄存器分配后，将当前寄存器分配情况记录在当前基本块的`RegSelect`中
      - 在`RegSelect`中，`tempId2Pos(Integer _tempId)`方法返回临时变量的位置，若t、s开头，则得到寄存器，若X开头，则说明当前临时变量在栈中
      - 计算Kanga过程声明中需要的三个参数

3. 生成Kanga语句 (`ToKangaVisitor extends GJDepthFirst<Object, Object>`)：
    - 由于Kanga语法和sPiglet十分相似，所以基本上只需结合当前基本块的`RegSelect`将对应临时变量替换为对应位置即可，若变量得到寄存器分配，直接替换为寄存器即可，若变量在栈中，则将其弹栈到`t0-t2`中，在填写对应临时寄存器
    - 在进入每个基本块时，结合当前基本块寄存器分配结果，将若干寄存器的值入栈，这些寄存器时活跃变量分析时替换入栈的寄存器，这是为了保证进入基本块之后，各个临时变量的对应关系符合`RegSelect`中记录的情况
    - 在生成Kanga语句时有几个难点：
       1. 生成`Exp`类型时的准备：如上所述，我们可能需要弹栈等操作为语句准备寄存器，所以在访问`Exp`类型时，分为两种情况，第一种情况作为存储器准备阶段，生成语句为当前语句准备寄存器，并将存储相关结果的寄存器名称记录在全局变量`exprNotes`中；第二种情况从`exprNotes`中读取对应结果，并打印出来，在两种情况之间打印语句的其他部分，如`MOVE`。
       2. 函数调用的翻译：Kanga和sPiglet在函数调用时的语法区别很大，实际上函数调用也是一种`Exp`类型，我们首先挑选一个临时寄存器(`t0-t2`)，传递参数到`a`寄存器，超过4个参数的部分通过`PASSARG`传递，因为我们将`s0-s7`、`t3-t9`都作为被调用者保存寄存器，所以这里不需要保存寄存器，调用函数后，将结果从`v0`寄存器中拷贝到之前的临时寄存器中作为结果寄存器，这个过程中，只需要一个临时寄存器即可。
       3. 进入一个新的过程的准备：这是Kanga和sPiglet另外一个很大的区别，在进入一个新的过程（或者叫做“函数”）时需要读取参数、保存寄存器等操作。在之前流图分析的寄存器分配的过程中，我们记录了当前过程所用到的所有寄存器，这里首先保存在栈中，注意此时入栈的位置从多余(>4)参数占据的位置之上开始计算，这里计算已占据的栈的空间，在这个过程中涉及到栈的位置的时候要加上这个基址，然后将参数从栈中或者`a`寄存器中传递给`s0-s7`、`t3-t9`，开始如下计算，最后返回值保存到`v0`中，并从栈中恢复`s0-s7`、`t3-t9`。
   
## 四、kanga->MIPS

1. 翻译为MIPS(`ToMIPSVisitor extends GJDepthFirst<MIPSReturn, MIPSLabel>`)
   - 返回值为一个类`MIPSReturn`，记录当前节点的返回类型。因为不同的类型是需要不同的MIPS指令
   - 输入参数是一个类`MIPSLabel`，记录标签是否需要输出。
2. 这一部分的翻译比较直白。基本上就是将kanga的每一句翻译为对应的MIPS指令。这里只介绍一些实现要点：
   - 栈帧维护：每一个函数的开始和结束部分需要对栈帧进行维护。首先将`bp`压栈，将`sp`存入`bp`，`sp`减去新栈帧的大小。在函数结束时需要进行复原，即上述过程的逆过程。
   - 临时变量和参数的保存传递：当函数调用需要构建参数或者将临时变量保存到栈中时，只需要根据`bp`定位到栈帧中的位置，进行读写即可。
   - 临时变量的使用：计算的过程，比如一些表达式计算或者是系统调用中有时候会用到临时变量，这里我都使用`a0`存放，因为在kanga中`a0`中的变量是需要马上保存的。
   - 空间申请以及输出：按照ppt上的做法，我事先先设计了对应的一些函数，包括申请空间以及打印信息。这里在实际的翻译过程中就是调用这些函数，这些函数会调用相应的系统调用实现相应的功能。

##五、项目说明

本项目主要包括三个包，分别是`minijava`包，`spiglet`包以及`kanga`包。其中`minijava`包包涵盖类型检查，符号表的构建以及minijava到spiglet的翻译程序。`spiglet`包主要包括中间代码的分析以及从spiglet到kanga的翻译。最后	`kanga`包包含从kanga翻译为最终MIPS的程序。三个包中都含有JTB以及javacc构建的语法分析树以及visitor。

项目主要给出了四个接口`Java2MIPS`，`Java2SPiglet`，`SPiglet2Kanga`以及`Kanga2MIPS`。四者分别将minijava程序翻译为MIPS，将minijava程序翻译为sPiglet，将sPiglet程序翻译为kanga以及将kanga程序翻译为MIPS。四个接口都可以接受命令行参数或者标准输入。在得到输入文件之后，程序会进行相应的处理并将最终结果输出到同目录下的文件。

以Java2MIPS为例，使用javac编译得到Java2MIPS.class后输入:

```shell
>java Java2MIPS ./temp/test.java
```

或者：

```shell
>java Java2MIPS 
./temp/test.java
```

